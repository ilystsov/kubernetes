[Вернуться][main]

---

# Использование сервиса (Service) для публикации (Expose) приложения

## Цели
- 

- Узнай, что такое сервис в Kubernetes
- Пойми, как метки и селекторы связаны с сервисом
- Вывод (Expose) приложения за пределы кластера Kubernetes с помощью сервиса

## Обзор сервисов Kubernetes

Поды Kubernetes смертны. Поды имеют жизненный цикл. Когда рабочий узел умирает, поды, запущенные на нём,
также теряются. ReplicaSet может динамически возвращать кластер в нужное состояние путем создания новых подов, чтобы
приложение продолжало работать. В качестве примера рассмотрим бэкенд для обработки изображений с 3
репликами. Эти реплики взаимозаменяемы; внешняя система не должна заботиться о репликах бэкенда или даже о том, теряется
ли под и создается ли он заново. При этом каждый под в кластере Kubernetes имеет уникальный IP-адрес, даже под на одном
узле, поэтому необходимо предусмотреть способ автоматического согласования изменений между подами, чтобы приложения
продолжали работать.

Сервис в Kubernetes - это абстракция, определяющая логический набор подсистем и политику доступа к ним. Сервисы
обеспечивают свободное взаимодействие между зависимыми подсистемами. Сервис определяется с помощью YAML или JSON, как и
все объектные манифесты Kubernetes. Набор подов, на которые нацелен сервис, обычно определяется селектором метки.

> Сервис Kubernetes - это уровень абстракции, определяющий логический набор подов и позволяющий передавать внешний
> трафик, балансировать нагрузку и находить сервисы для этих подов.

Хотя каждый под имеет уникальный IP-адрес, эти IP-адреса не открыты за пределами кластера без сервиса. Сервисы позволяют
вашим приложениям получать трафик. Сервисы можно открывать различными способами, указывая тип в спецификации сервиса:

- **ClusterIP** (по умолчанию) - предоставляет сервис на внутреннем IP-адресе кластера. Этот тип делает сервис доступным
  только изнутри кластера.
- **NodePort** - Выставляет сервис на один и тот же порт каждого выбранного узла в кластере с помощью NAT. Делает сервис
  доступным извне кластера, используя <NodeIP>:<NodePort>. Суперсет ClusterIP.
- **LoadBalancer** - создает внешний балансировщик нагрузки в текущем облаке (если поддерживается) и назначает
  фиксированный
  внешний IP для сервиса. Суперсет NodePort.
- **ExternalName** - Сопоставляет сервис с содержимым поля externalName (например, foo.bar.example.com), возвращая
  CNAME-запись с его значением. Никакого проксирования не устанавливается. Для этого типа требуется версия 1.7 или выше
  kube-dns, или CoreDNS версии 0.0.8 или выше.

Важно обратить внимание, что есть некоторые случаи использования сервисов, которые предполагают отсутствие
определения селектора в спецификации. Сервис, созданный без селектора, также не создаст соответствующий объект
конечных точек. Это позволяет пользователям вручную сопоставлять сервис с определёнными конечными точками. Другая
возможность отсутствия селектора заключается в том, что мы строго используем тип: ExternalName.

## Сервисы и метки (Labels)

Сервис маршрутизирует трафик между набором подов. Сервисы - это абстракция, которая позволяет подам умирать и
реплицироваться в Kubernetes без ущерба для приложения. Обнаружение и маршрутизация между зависимыми подами, например,
фронтенд и бэкенд-компоненты в приложении, осуществляются с помощью сервисов Kubernetes.

Сервисы сопоставляют набор подов с помощью меток и селекторов - примитивов группировки, которые позволяют логически
оперировать объектами в Kubernetes. Метки - это пары ключ/значение, прикрепленные к объектам, и могут использоваться
любым способом:

- Назначить объекты для разработки, тестирования и производства
- Встраивать метки версий
- Классифицировать объект с помощью меток

![](https://kubernetes.io/docs/tutorials/kubernetes-basics/public/images/module_04_labels.svg)

Метки можно прикрепить к объектам в момент создания или позже. Они могут быть изменены в любое время. Давай
представим приложение с помощью сервисов и наложим присвоим меток.

## Шаг 1: Создание нового сервиса

Давай проверим, что приложение запущено. Воспользуемся командой kubectl get и поищем существующие поды:

```sh
kubectl get pods
```

Если ни один под не запущен, значит, объекты из предыдущих шагов были очищены. В этом случае вернись назад и заново
создай развёртывание. Подожди пару секунд и снова просмотри список подов. Можешь продолжить, как только увидишь
хотя бы один запущенный под.

Далее выведи список текущих сервисов кластера:

```sh
kubectl get services
```

У нас есть сервис kubernetes, который создаётся по умолчанию, когда minikube запускает кластер. Чтобы создать новый
сервис и открыть его для внешнего трафика, воспользуйся командой expose с NodePort в качестве параметра.

```sh
kubectl expose deployment/kubernetes-bootcamp --type="NodePort" --port 8080
```

Снова запустим подкоманду get services:

```sh
kubectl get services
```

Теперь у нас есть запущенный сервис kubernetes-bootcamp. Здесь мы видим, что сервис получила уникальный кластерный IP,
внутренний порт и внешний IP (IP узла).

Чтобы узнать, какой порт был открыт извне (для типа: NodePort Service), выполни подкоманду describe service:

```sh
kubectl describe services/kubernetes-bootcamp
```

Создай переменную окружения NODE_PORT, которой будет присвоено значение порта узла:

```sh
export NODE_PORT="$(kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}')"
echo "NODE_PORT=$NODE_PORT"
```

Теперь можем проверить, что приложение открыто за пределами кластера, используя curl, IP-адрес узла и порт,
открываемый извне:

```sh
curl http:// "$(minikube ip):$NODE_PORT"
```

> Примечание:
> Если используешь minikube с Docker Desktop в качестве драйвера контейнера, туннель minikube необходим.
> Это связано с тем, что контейнеры внутри Docker Desktop изолированы от вашего хост-компьютера.
>
> В отдельном окне терминала выполните:
> ```sh
> minikube service kubernetes-bootcamp --url
> ```
> Вывод будет примерно таким:
> ```sh
> http://127.0.0.1:52438
> !  Because you are using a Docker driver on darwin, the terminal needs to be open to run it.
> ```
>
> Затем используй указанный URL для доступа к приложению:
> ```sh
> curl 127.0.0.1:52438
> ```

И мы получаем ответ от сервера. Сервис открыт.

## Шаг 2: Использование меток

Развёртывание автоматически создало метку для нашего пода. С помощью подкоманды describe deployment можно увидеть
имя (ключ) этой метки:

```sh
kubectl describe deployment
```

Давай используем этe метку для запроса списка подов. Используй команду kubectl get pods с флагом `-l`, за
которым следуют значения меток:

```sh
kubectl get pods -l app=kubernetes-bootcamp
```

То же самое можно проделать для получения списка существующих сервисов:

```sh
kubectl get services -l app=kubernetes-bootcamp
```

Получи имя пода и сохрани его в переменной окружения POD_NAME:

```sh
export POD_NAME="$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')"
echo "Name of the Pod: $POD_NAME"
```

Чтобы применить новую метку, используй подкоманду label, за которой следует тип объекта, имя объекта и новая метка:

```sh
kubectl label pods "$POD_NAME" version=v1
```

Это применит новую метку к поду (прикрепление версии приложения к поду), и можно проверить его с помощью
команды describe pod:

```sh
kubectl describe pods "$POD_NAME"
```

Из вывода видно, что метка теперь прикреплена к поду. И теперь можно запросить список подов, используя новую метку:

```sh
kubectl get pods -l version=v1
```

## Шаг 3: Удаление сервисов

Для удаления сервисов можно использовать подкоманду delete service. Здесь также можно использовать метки:

```sh
kubectl delete service -l app=kubernetes-bootcamp
```

Убедись, что сервис удалён:

```sh
kubectl get services
```

Из вывода видно, что сервис был удалён. Чтобы убедиться в том, что маршрут больше не раскрыт, можно просмотреть
ранее раскрытые IP и порт:

```sh
curl http:// "$(minikube ip):$NODE_PORT".
```

Из вывода видно, что приложение больше недоступно извне кластера. Можно проверить, что приложение всё ещё
работает, выполнив curl изнутри пода:

```sh
kubectl exec -ti $POD_NAME -- curl http://localhost:8080.
```

Здесь видно, что приложение работает. Потому, что развёртывание управляет приложением. Чтобы закрыть приложение, 
нужно будет удалить и развёртывание.


---

[Вернуться][main]


[main]: ../../README.md "содержание"
