[Вернуться][main]

---

# Просмотр подов и узлов

## Цели

- Узнай о Pods.
- Узнай о Nodes.
- Устрани неполадки в развёрнутых приложениях.

## Kubernetes Pods

Когда создали развёртывание, Kubernetes создал Pod для размещения экземпляра приложения. Pod - это
абстракция Kubernetes, которая представляет собой группу из одного или нескольких контейнеров приложений (например,
Docker), а также некоторые общие ресурсы для этих контейнеров. К таким ресурсам относятся:

- общее хранилище, как тома (volumes)
- сетевые ресурсы в виде уникального IP-адреса кластера
- информация о том, как запустить каждый контейнер, например версия образа контейнера или конкретные порты, которые
  необходимо использовать.

Pod моделирует специфический для приложения "логический хост" и может содержать различные контейнеры приложений, которые
относительно тесно связаны между собой. Например, в Pod может входить как контейнер с приложением Node.js, так и
другой контейнер, в который поступают данные для публикации веб-сервером Node.js. Контейнеры в Pod имеют общий IP-адрес
и порт, всегда находятся в одном месте и расписании, а также работают в общем контексте на одном и том же узле.

Pod-ы - это атомарная единица платформы Kubernetes. Когда создаём развертывание на Kubernetes, это
развёртывание создает поды с контейнерами внутри них (в отличие от создания контейнеров напрямую). Каждый Pod привязан к
узлу, на котором он запланирован, и остаётся там до завершения (в соответствии с политикой перезапуска) или удаления. В
случае отказа узла идентичные поды планируются на других доступных узлах кластера.

### Визуализация подов:

![](https://kubernetes.io/docs/tutorials/kubernetes-basics/public/images/module_03_pods.svg)

> Pod - это группа из одного или нескольких контейнеров приложений (например, Docker), включающая в себя общее
> хранилище (тома), IP-адрес и информацию о том, как их запускать.

## Узлы (Nodes)

Pod всегда выполняется на узле. Узел (Node) - это рабочая машина в Kubernetes, которая может быть как виртуальной, так и
физической, в зависимости от кластера. Каждый узел управляется control plane. На узле может быть несколько
подов, и control plane Kubernetes автоматически распределяет поды по узлам кластера. При автоматическом
планировании control plane учитывает доступные ресурсы на каждом узле.

На каждом узле Kubernetes работает как минимум:

- Kubelet, процесс, отвечающий за связь между control plane Kubernetes и узлом, он управляет подами и
  контейнерами, запущенными на машине.
- Рантайм контейнер (например, Docker), отвечающий за извлечение (pulling) образа контейнера из реестра контейнеров,
  распаковку контейнера и запуск приложения.

> Контейнеры следует планировать вместе в одном Pod только в том случае, если они тесно связаны между собой и должны
> совместно использовать ресурсы, такие как диск.

### Визуализация узлов:

![](https://kubernetes.io/docs/tutorials/kubernetes-basics/public/images/module_03_nodes.svg)

> Узел - это рабочая машина в Kubernetes, которая может быть виртуальной или физической машиной, в зависимости от
> кластера. На одном узле может работать несколько подов.

## Устранение неполадок с помощью kubectl

Мы использовали интерфейс командной строки kubectl. Наиболее распространенные операции можно выполнить с помощью
следующих подкоманд kubectl:

- `kubectl get` - список ресурсов
- `kubectl describe` - показать подробную информацию о ресурсе
- `kubectl logs` - показать логи из контейнера в поде
- `kubectl exec` - выполнить команду на контейнере в поде.

С помощью этих команд можно узнать, когда были развёрнуты приложения, каково их текущее состояние, где они запущены и
какова их конфигурация.

Теперь, когда мы знаем больше о компонентах кластера и командной строке, изучим приложение.

### Проверка конфигурации приложения

Проверим, что приложение, которое развернули ранее, запущено.
Воспользуемся командой kubectl get и поищем существующие поды:

```sh
kubectl get pods
```

Если ни один из подов не запущен, подожди пару секунд и просмотри список подов снова. Можно продолжить,
как только увидим хотя бы один запущенный Pod.

Далее, чтобы посмотреть, какие контейнеры находятся внутри этого Pod и какие образы используются для создания этих
контейнеров, выполним команду kubectl describe pods:

```sh
kubectl describe pods
```

Здесь мы видим подробную информацию о контейнере Pod-а: IP-адрес, используемые порты и список событий, связанных с
жизненным циклом Pod.

> Примечание: подкоманда describe может быть использована для получения подробной информации о большинстве примитивов
> Kubernetes, включая узлы, поды и развёртывания. Вывод describe предназначен для чтения человеком, а не для написания
> скриптов.

### Отображение приложение в терминале

Поды работают в изолированной частной сети - поэтому нам нужно проксировать доступ к ним, чтобы мы могли
отлаживать и взаимодействовать с ними. Для этого мы воспользуемся командой kubectl proxy, чтобы запустить прокси во
втором терминале. Открой новое окно терминала и в нём выполни команду:

```sh
kubectl proxy
```

Теперь мы снова получим имя пода и запросим его напрямую через прокси. Чтобы получить имя Pod и сохранить его в
переменной окружения POD_NAME:

```sh
export POD_NAME="$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')"
echo Name of the Pod: $POD_NAME
```

Чтобы увидеть результаты работы нашего приложения, выполни запрос curl:

```sh
curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME:8080/proxy/
```

URL - это маршрут к API бода.

### Просмотр логов контейнера

Всё, что приложение обычно отправляет в стандартный вывод, становится логами для контейнера в Pod. Мможно получить эти
логи с помощью команды kubectl logs:

```sh
kubectl logs "$POD_NAME"
```

> Примечание: Не нужно указывать имя контейнера, потому что у нас только один контейнер внутри пода.

### Выполнение команд на контейнере

Можно выполнять команды непосредственно на контейнере, когда под запущен и работает. Для этого используем
подкоманду exec, а в качестве параметра указываем имя пода. Давай выведем список переменных окружения:

```sh
kubectl exec "$POD_NAME" -- env
```

Опять же, стоит отметить, что имя самого контейнера можно не указывать, так как у нас только один контейнер в Pod.

Далее давай запустим bash-сессию в контейнере Pod:

```sh
kubectl exec -ti $POD_NAME -- bash
```

Теперь у нас есть открытая консоль на контейнере, в котором мы запускаем наше NodeJS-приложение. Исходный код приложения
находится в файле server.js:

```sh
cat server.js
```

Проверить работоспособность приложения можно, выполнив команду curl:

```sh
curl http://localhost:8080
```

Примечание: здесь мы использовали localhost, потому что выполняли команду внутри NodeJS Pod. Если не можем
подключиться к localhost:8080, проверь, выполнили ли вы команду kubectl exec и запускаешь ли команду из контейнера.

Чтобы закрыть соединение с контейнером, введи `exit`.

---

[Вернуться][main]


[main]: ../../README.md "содержание"

[Pigeonhole_principle]: https://ru.wikipedia.org/wiki/Принцип_Дирихле_(комбинаторика) "pigeonhole principle"
