[Вернуться][main]

---

# Использование kubectl для создания развёртывания (Deployment)

## Цели
- Узнай о развёртывании приложений.
- Разверни своё приложение на Kubernetes с помощью kubectl.

## Развёртывания (Deployments) Kubernetes

После того как мы создали кластер Kubernetes, мы можем развернуть на нём свои контейнерные приложения.
Для этого мы создаём развёртывание Kubernetes.
Развёртывание указывает Kubernetes, как создавать и обновлять экземпляры приложения.
После создания развёртывания control plane Kubernetes планирует запуск экземпляров приложений,
включенных в это развёртывание, на отдельных узлах кластера.

После создания экземпляров приложения контроллер развертывания Kubernetes непрерывно следит за этими экземплярами.
Если узел, на котором расположен экземпляр, выходит из строя или удаляется, контроллер развертывания заменяет его
экземпляром на другом узле кластера. Это обеспечивает механизм самовосстановления для решения проблемы отказа или
обслуживания машины.

В прошлом, когда оркестрация не была развита, для запуска приложений часто использовались сценарии установки,
но они не позволяли восстанавливаться после сбоя машины. Создавая экземпляры приложений и поддерживая их работу
на разных узлах, развёртывания Kubernetes обеспечивают принципиально иной подход к управлению приложениями.

### Deploying приложения на Kubernetes

![image](https://kubernetes.io/docs/tutorials/kubernetes-basics/public/images/module_02_first_app.svg)

Можно создавать и управлять развёртыванием с помощью интерфейса командной строки Kubernetes, kubectl.
Kubectl использует API Kubernetes для взаимодействия с кластером.

При создании развёртывания нужно будет указать образ контейнера для приложения и количество реплик,
которые необходимо запустить. Позже можно изменить эту информацию, обновив развёртывание.

Для развертывания на Kubernetes приложения должны быть упакованы в один из поддерживаемых форматов контейнеров.

Для развёртывания будем использовать приложение hello-node, упакованное в контейнер Docker,
которое использует NGINX для отправки всех запросов.

## Основы kubectl

Обычный формат команды kubectl выглядит так: 

```sh
kubectl action resource
```

Команда выполняет указанное действие (например, создание, описание или удаление) над указанным ресурсом
(например, узлом или развёртыванием). Можно использовать опцию `--help` после подкоманды, чтобы получить дополнительную
информацию о возможных параметрах, например:

```sh
kubectl get nodes --help
```

Проверить, что kubectl настроен на взаимодействие с кластером можно выполнив команду:

```sh
kubectl version
```

Чтобы просмотреть узлы в кластере можно выполнить команду:

```sh
kubectl get nodes
```

В выводе будут показаны доступные узлы.
Позже Kubernetes выберет, где развернуть приложение, основываясь на доступных ресурсах узлов.

## Deploy приложения

Развернём приложение на Kubernetes с помощью команды kubectl create deployment.
Нужно указать имя развертывания и местоположение образа приложения
(для образов, размещенных вне Docker Hub, укажи полный адрес репозитория).

```sh
kubectl create deployment kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1
```

Супер! Только что развернули приложение, создав Deployment.
Он выполнил для несколько действий:

- поиск подходящей ноды, на котором может быть запущен инстанс приложения (у нас есть только 1 доступная нода)
- запланировали запуск приложения на этом узле
- настроил кластер, чтобы при необходимости перепланировать экземпляр на новый узел.

Чтобы получить список Deployments, воспользуйся командой kubectl get deployments:

```sh
kubectl get deployments
```

Мы видим, что существует 1 Deployment, в котором запущен единственный экземпляр приложения.
Этот экземпляр запущен внутри контейнера на узле.

## Просмотр приложения

Pod-ы, запущенные внутри Kubernetes, работают в частной, изолированной сети.
По умолчанию они видны другим Pod-ам и сервисам в том же кластере Kubernetes, но не за пределами этой сети.
Когда мы используем kubectl, мы взаимодействуем через конечную точку API для связи с нашим приложением.

Команда kubectl proxy может создать прокси, который будет перенаправлять соединения в частную сеть всего кластера.
Прокси можно завершить нажатием control-C, и во время работы он не будет показывать никаких результатов.

Чтобы запустить прокси, необходимо открыть второе окно терминала.

```sh
kubectl proxy
```

Теперь у нас есть соединение между нашим хостом (терминалом) и кластером Kubernetes.
Прокси обеспечивает прямой доступ к API с этих терминалов.

Можно видеть все API, размещённые через конечную точку прокси.
Например, мы можем запросить версию непосредственно через API с помощью команды curl:

```sh
curl http://localhost:8001/version
```

> Примечание: Если порт 8001 недоступен, убедись, что во втором терминале запущен прокси kubectl, который запустили ранее.

Сервер API автоматически создаст конечную точку для каждого Pod-а, основанную на имени Pod-а,
которая также будет доступна через прокси.

Сначала нам нужно получить имя Pod-а, и мы сохраним его в переменной окружения `POD_NAME`:

```sh
export POD_NAME=$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{"\n"}}{{end}}')
echo Имя Pod-a: $POD_NAME
```

Можно получить доступ к подбору через проксированный API, выполнив команду:

```sh
curl http://localhost:8001/api/v1/namespaces/default/pods/$POD_NAME/.
```

Для того чтобы новый Deployment был доступен без использования прокси, необходим сервис.


---

[Вернуться][main]


[main]: ../../README.md "содержание"
